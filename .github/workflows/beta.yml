name: Beta Release

env:
  REPO_NAME: arkade-lvlup
  GITHUB_TOKEN: ${{ secrets.MY_PAT }}
  RELEASE_NAME: Beta Release
  RELEASE_TYPE: beta

on:
  push:
    branches:
      - develop

# ----------- CI SECTION -----------

jobs:
  setup-info:
    name: Prelimenary steps
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ env.TAG_NAME }}
    steps:
      
      - name: Extract type and name from GITHUB_REF
        id: extract-ref
        shell: bash
        run: |
          set -e
          trap 'handle_error $LINENO' ERR
          handle_error() {
            echo "Error occurred at line $1. Exiting."
            exit 1
          }
          
          # Extract the type (branch or tag) and its name from the GITHUB_REF variable
          REF_TYPE=$(echo ${GITHUB_REF#refs/} | cut -d'/' -f1)
          REF_NAME=$(echo ${GITHUB_REF#refs/*/})
          
          if [[ -z "$REF_TYPE" || -z "$REF_NAME" ]]; then
            echo "Error: Failed to extract REF_TYPE or REF_NAME from GITHUB_REF. Exiting."
            exit 1
          fi
          echo "REF_TYPE=$REF_TYPE" >> $GITHUB_ENV
          echo "REF_NAME=$REF_NAME" >> $GITHUB_ENV
          
      - name: Set tag name
        id: set-tag-name
        shell: bash
        run: |
          if [[ "${{ env.REF_TYPE }}" == "tags" ]]; then
            if [[ -z "${{ env.REF_NAME }}" ]]; then
              echo "Error: REF_NAME for tag is empty."
              exit 1
            fi
            echo "TAG_NAME=${{ env.REF_NAME }}" >> $GITHUB_ENV
          fi
      

  build:
    name: Build & Test
    needs: [setup-info]
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        goarch: [amd64, arm64]
   
    steps:
      - name: Checkout code
        uses: actions/checkout@v3     
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.21

      # Cache was causing errors, turned off until further evaluation
      # - name: Cache dependencies
      #   uses: actions/cache@v3
      #   with:
      #     path: ~/go/pkg/mod
      #     key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
      #     restore-keys: |
      #       ${{ runner.os }}-go-
      #   env:
      #     GO111MODULE: on
        
      - name: Download dependencies
        run: go mod download
    
      # - name: Test
      #   run: go test ./...
    
      - name: Build binary
        run: |
          go build -o ${{ env.REPO_NAME }}-${{ matrix.os }}-${{ matrix.goarch }}${{ runner.os == 'Windows' && '.exe' || '' }}-${{ env.RELEASE_TYPE }} .

      - name: Archive artifacts
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.REPO_NAME }}-${{ matrix.os }}-${{ matrix.goarch }}-${{ env.RELEASE_TYPE }}
          path: ./${{ env.REPO_NAME }}-${{ matrix.os }}-${{ matrix.goarch }}${{ runner.os == 'Windows' && '.exe' || '' }}-${{ env.RELEASE_TYPE }}
            

# ----------- CD SECTION -----------         

  prune-releases:
    name: Prune Releases and Tags
    needs: [setup-info]
    runs-on: ubuntu-latest

    steps:
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Checkout code
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.MY_PAT }}
          
      - name: Delete old release
        run: |
          set -e
          trap 'handle_error $LINENO' ERR
          # Check if a release exists and delete it
          if gh release view ${{ env.RELEASE_TYPE }} > /dev/null 2>&1; then
              gh release delete ${{ env.RELEASE_TYPE }} -y
              echo "Successfully deleted the ${{ env.RELEASE_TYPE }} release."
          else
              echo "No ${{ env.RELEASE_TYPE }} release found."
          fi        

      - name: Delete old ${{ env.RELEASE_TYPE }} tag locally and remotely
        run: |
          # Check if local tag exists and delete
          if git tag | grep -q '^${{ env.RELEASE_TYPE }}$'; then
            git tag -d ${{ env.RELEASE_TYPE }} 
            echo "Successfully deleted the ${{ env.RELEASE_TYPE }} tag locally."
          else
            echo "No local ${{ env.RELEASE_TYPE }} tag found."
          fi
          
          # Debug: Print remote tags
          echo "Listing remote tags:"
          git ls-remote --tags origin
      
          # Check if remote tag exists and delete
          if git ls-remote --tags origin | grep -q 'refs/tags/${{ env.RELEASE_TYPE }}'; then
            git push origin :refs/tags/${{ env.RELEASE_TYPE }} 
            echo "Successfully deleted the ${{ env.RELEASE_TYPE }} tag remotely."
          else
            echo "No remote ${{ env.RELEASE_TYPE }} tag found."
          fi

      - name: Create new tag
        run: |
          git tag ${{ env.RELEASE_TYPE }}
          git push origin ${{ env.RELEASE_TYPE }}
          echo "Successfully created the new ${{ env.RELEASE_TYPE }} tag."
  

  generate-changelog:
    name: Generate Changelog
    runs-on: ubuntu-latest
    outputs:
      changelog: ${{ env.CHANGELOG }}
      commit_messages: ${{ env.COMMIT_MESSAGES }}
  
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.MY_PAT }}

      - name: Get base commit
        id: base_commit
        run: |
          git branch -a
          BASE_COMMIT=$(git merge-base HEAD origin/develop) || echo "Failed to determine merge-base."
          echo "BASE_COMMIT is: $BASE_COMMIT"
          echo "BASE_COMMIT=$BASE_COMMIT" >> $GITHUB_ENV
        
      - name: Extract Commit Messages since BASE_COMMIT
        id: get-changelog
        run: |
          COMMIT_MESSAGES=$(git log $BASE_COMMIT..HEAD --pretty=format:"- %s" | tr '\n' ' ')
          echo "Captured Commit Messages: $COMMIT_MESSAGES"
          echo "COMMIT_MESSAGES=$COMMIT_MESSAGES" >> $GITHUB_ENV
        
      - name: Generate changelog using Docker
        run: |
          set -e
          trap 'handle_error $LINENO' ERR
          docker run --rm \
          -v "/home/runner/work/${{ env.REPO_NAME }}/${{ env.REPO_NAME }}":/usr/local/src/${{ env.REPO_NAME }} \
          -w /usr/local/src/${{ env.REPO_NAME }} \
          -e GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }} \
          githubchangeloggenerator/github-changelog-generator \
          --user="${{ github.repository_owner }}" --project="${{ env.REPO_NAME }}" --token ${{ secrets.GITHUB_TOKEN }}
      
      - name: Encode Changelog to Environment File
        run: |
          echo "CHANGELOG=$(cat CHANGELOG.md | base64 -w 0)" >> $GITHUB_ENV
                        

  release:
    name: Create Release and Upload Assets
    needs: [build, prune-releases, generate-changelog]
    if: github.event_name == 'push'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Decode Changelog from Environment Variable
        run: |
          echo "${{ needs.generate-changelog.outputs.changelog }}" | base64 -d > DECODED_CHANGELOG.md           
          cat DECODED_CHANGELOG.md 

      - name: Download all built artifacts
        uses: actions/download-artifact@v3
        with:
          path: ./artifacts

      - name: List Artifacts Directory
        run: |
          ls -R ./artifacts/
      
      - name: Create Release
        run: |
          set -e
          trap 'handle_error $LINENO' ERR
          RELEASE_NAME="${{ env.RELEASE_NAME }} $(date -u +"%Y-%m-%d_%H-%M")"
          CHANGLOG_CONTENT=$(cat DECODED_CHANGELOG.md)
          COMMIT_CONTENT="${{ needs.generate-changelog.outputs.commit_messages }}"
          FULL_CONTENT="$CHANGLOG_CONTENT\n\n$COMMIT_CONTENT"
          gh release create ${{ env.RELEASE_TYPE }} \
          --title "$RELEASE_NAME" \
          --notes "$FULL_CONTENT" \
          --draft
                
      - name: Upload Files to Release
        run: |
          TAG="${{ env.RELEASE_TYPE }}"
          FILES=$(ls ./artifacts/*/*)
          for FILE in $FILES; do
            gh release upload $TAG $FILE
          done
